%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                              %
%            A Painless Introduction to Programming UAMMD Modules              %
%                    Chapter 2: Unleash your own potential                     %
%                                                                              %
%                          Marc Mel√©ndez Schofield                             %
%                                                                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

You can only have so much fun playing with a Lennard-Jones simulation. Changing
the parameter values and then looking for differences in your plots gets old
soon. If you've made it this far, you want more. You imagine molecules, or
larger structures. Perhaps you'd like to simulate billowing smoke, sloshing
water, or planets orbiting a star. All in good time.

Whatever your final aim, you need new interactions, and this chapter contains a
good collection of them.

\section{Harmonic bonds}

The simplest permanent link between particles in UAMMD has to be the harmonic
bond. Think of it as an invisible linear spring connecting two particles. As
long as they remain at the equilibrium distance $r_0$, they exert no force on
each other, but when you stretch their separation $r$, they pull back. The
potential function for this bond, then, equals
\begin{equation*}
  V(r) = \frac{1}{2}\ K\ (r - r_0)^2,
\end{equation*}
where the spring constant $K$ quantifies the bond rigidity.

Take a string of one hundred and one particles as our explanatory device. We
will line them all up along a curved queue, standing initially at rest.
\label{stringInitialConditions}
\begin{lstlisting}
%! codeblock: stringInitialConditions
  int numberOfParticles = 101;
  auto particles
    = make_shared<ParticleData>(numberOfParticles, sys);

  {
    auto position
      = particles->getPos(access::location::cpu,
                          access::mode::write);
    auto velocity
      = particles->getVel(access::location::cpu,
                          access::mode::write);

    real amplitude = 0.1;
    real stringLength = 1.0;
    int modenum = 1;
    for(int i = 0; i < numberOfParticles; ++i) {
      position[i].x = i*(stringLength/(numberOfParticles - 1));
      position[i].y = amplitude*sin(modenum*M_PI*position[i].x);
      position[i].z = position[i].w = 0;
      velocity[i].x = velocity[i].y = velocity[i].z = 0;
    }
  } //!
%! codeblockend !//
\end{lstlisting}

UAMMD reads bond information in from an external file. Let me first explain the
format of this plain text bond file. It should look something like this:
\begin{lstlisting}
100
0 1 1000.0 0.01
1 2 1000.0 0.01
2 3 1000.0 0.01
3 4 1000.0 0.01
    . . .
\end{lstlisting}
and so on. The file begins with the number of bonds ($100$) followed by a row
for each bond presenting $i$, $j$, $K$ and $r_0$, that is, the particle ID
numbers, the bond spring constant and the equilibrium distance. Hence, the next
line links particles $0$ and $1$ with a bond of $K = 1000.0$ and $r_0 = 0.01$.
After that, we get the values for the bond connecting particles $1$ and $2$.
Even though I have chosen identical values of $K$ and $r_0$ for all the bonds in
this example, you can of course make them all different if you like.

In addition to linking particles, you can attach them to fixed points in space.
We will pin particle $0$ to the origin of coordinates and particle $100$ to
point $(1, 0, 0)$. After the previous list of bonds, we must include the number
of fixed bonds (only $2$ in our case). The format for these is simply $i$, $x$,
$y$, $z$, $K$, $r_0$, meaning: particle ID, position in space $(x, y, z)$,
spring constant and equilibrium distance. So in our example, the bond file
should end with:
\begin{lstlisting}
2
0 0 0 0 1000.0 0.0
100 1 0 0 1000.0 0.0
\end{lstlisting}
With the ends held in place, we have a taut string. As soon as we let go and run
the simulation, it should vibrate.

We will make the program write the bond information so that we don't have to.
\begin{lstlisting}
%! codeblock: stringBondFile
  {
    std::ofstream bondInfo("data.bonds");
    if(not bondInfo.is_open()) {
      sys->log<System::CRITICAL>("Unable to create data.bonds file. Halting program.");
      exit(-1);
    }

    bondInfo<<(numberOfParticles - 1)<<endl;
    for(int i = 0; i < numberOfParticles - 1; ++i) {
      bondInfo<<i<<" "<<(i + 1)<<" 1000.0 0.01"<<endl;
    }
    bondInfo<<"2"<<endl;
    bondInfo<<"0 0 0 0 1000.0 0.0"<<endl;
    bondInfo<<"100 1 0 0 1000.0 0.0"<<endl;
  } //!
%! codeblockend !//
\end{lstlisting}

Including the bonds presents no difficulties from the point of view of UAMMD
code, as the code resembles the lines we wrote for the Lennard-Jones
interaction. You insert the customary include at the top,
\begin{lstlisting}
# include "Interactor/BondedForces.cuh"
\end{lstlisting}
define the interaction parameters to create the ``interactor'',
\begin{lstlisting}
%! codeblock: stringBondInteractor
  {
    using HarmonicBonds = BondedForces<BondedType::Harmonic>;
    HarmonicBonds::Parameters bondParameters;
    bondParameters.file = "data.bonds";
    auto bonds = make_shared<HarmonicBonds>(particles, sys, bondParameters); //!
%! codeblockend !//
\end{lstlisting}
and then add the new bond interaction to the integrator.
\begin{lstlisting}
%! codeblock: stringAddInteractor
    integrator->addInteractor(bonds);
  } //!
%! codeblockend !//
\end{lstlisting}

To replicate the simulation results shown in Figure \ref{vibratingString},
set the integrator parameters to these values:
\begin{lstlisting}
%! codeblock: VerletParameters
  using Verlet = VerletNVE;
  Verlet::Parameters VerletParams;
  VerletParams.dt = 0.001;
  VerletParams.initVelocities=false; //!
%! codeblockend !//
\end{lstlisting}
For the figure, I simulated twenty thousand steps and output the positions every
two thousand. Because I did not need a simulation box in this case, I eliminated
the corresponding block of code and changed the output command.
\begin{lstlisting}
      out<<endl;
      for(int id = 0; id < numberOfParticles; ++id)
        out<<position[index[id]]<<endl;
\end{lstlisting}

\begin{comment}
Vibrating string simulation code:
\begin{lstlisting}
%! codefile: code/vibratingString.cu
# include "uammd.cuh"
# include "utils/InitialConditions.cuh"
# include "Interactor/BondedForces.cuh"
# include "Integrator/VerletNVE.cuh"

using namespace uammd;
using std::make_shared;
using std::endl;

int main(int argc, char *argv[]){

  auto sys = make_shared<System>(argc, argv);

  %! codeinsert: stringInitialConditions

  %! codeinsert: VerletParameters

  %! codeinsert: Verlet src: chapters/first_simulation.tex

  %! codeinsert: stringBondFile

  %! codeinsert: stringBondInteractor

  %! codeinsert: stringAddInteractor

  std::string outputFile = "vibratingString.dat";
  std::ofstream out(outputFile);

  int numberOfSteps = 20000;
  int printEverynSteps = 2000;

  %! codeblock: integrate
  for(int step = 0; step < numberOfSteps; ++step) {
    integrator->forwardTime();

    if(printEverynSteps > 0
       and step % printEverynSteps == 1) {
      auto position
        = particles->getPos(access::location::cpu,
                            access::mode::read);
      const int * index = particles->getIdOrderedIndices(access::location::cpu);

      out<<endl;
      for(int id = 0; id < numberOfParticles; ++id)
        out<<position[index[id]]<<endl;
    }
  }
  %! codeblockend

  sys->finish();

  return 0;
}
%! codeend
\end{lstlisting}
\end{comment}

\begin{figure}
  \centering
  \includegraphics[width = 0.6 \textwidth]{figures/vibratingString.eps}
  \caption{\label{vibratingString}A chain of $101$ particles connected with
           harmonic bonds and ends tethered to fixed points. It (imperfectly)
           follows the behaviour of the ideal vibrating string. The first four
           normal modes of vibration were achieved by setting the
           \texttt{modenum} variable (see page
           \pageref{stringInitialConditions}) to $n = 1, 2, 3,$ and $4$.}
\end{figure}

\section{External fields}

Figure \ref{vibratingString} may hold the attention of harmonic analysis
enthusiasts but, personally, I cannot wait to free the chain of particles at one
end and simulate a swinging rope. We already know how to deal with the bonds.
Just eliminate the final fixed bond in the data.bonds file, leaving the end of
the file like this:
\begin{lstlisting}
1
0 0 0 0 1000.0 0.0
\end{lstlisting}

We are holding our chain only from the side at the origin of coordinates, but if
we expect to watch it swing back and forth, we cannot forget to implement the
force driving this motion: gravity.

Surely, we can add gravity into the mix with ease, right? It cannot be worse
than the Lennard-Jones potential or harmonic bonds. Well \ldots in a sense, it
does not differ much. You can incorporate it just as you would any other
interaction. Unfortunately, UAMMD was not designed with a standard gravity
interaction in mind, so we will have to write our own. Not to worry, though. We
will find it instructive and not too difficult.

In our model, gravity will appear as an external force field, meaning that it
does not act as an interaction among particles, but rather a force field that
affects each of them independently of the motions of the other particles. Thus,
\begin{lstlisting}
# include "Interactor/ExternalForces.cuh"
\end{lstlisting}

An external force definition consists of four parts:
\begin{enumerate}
  \item A setup.
  \item A rule for how to calculate the force on a particle.
  \item A rule for the particle energy due to the external field.
  \item A function that obtains the information needed to calculate the force
        and energy.
\end{enumerate}
In terms of code, we create a data structure with a real value $g$ for the
accleration of gravity.
\begin{lstlisting}
%! codeblock: gravityDefinition
struct gravitationalForce{
  real g;
%! codeinsert: gravityConstructor
%! codeinsert: gravityForce
%! codeinsert: gravityEnergy
%! codeinsert: gravityParticleInfo
}; //!
%! codeblockend !//
\end{lstlisting}
Now, between the declaration of $g$ and the closing bracket, we will insert the
four items listed above, beginning with a function that initialises the force.
It should only do one thing, take the numerical value given to $g$ and assign it
to the variable \texttt{g}. We can code it as an empty function. This type of 
function is known as a constructor and is named like the data structure.
\begin{lstlisting}
%! codeblock: gravityConstructor
  gravitationalForce(real numericalValueOfg):g(numericalValueOfg){} //!
%! codeblockend !//
\end{lstlisting}
The second item (the force) equals the mass of the particle times $-g$ in the
$y$ direction.
\begin{lstlisting}
%! codeblock: gravityForce
  __device__ real3 force(real4 position, real mass){
    return make_real3(0.0f, -mass*g, 0.0f);
  } //!
%! codeblockend !//
\end{lstlisting}
(The \texttt{\_\_device\_\_} indicates that the calculation will take place on 
your graphics processor unit). Next, we write the function for the gravitational 
potential energy.
\begin{lstlisting}
%! codeblock: gravityEnergy
  __device__ real energy(real4 position, real mass){
    return mass*g*position.y;
  } //!
%! codeblockend !//
\end{lstlisting}
We end the data structure telling the interaction where to get the position and
mass information.
\begin{lstlisting}
%! codeblock: gravityParticleInfo
  auto getArrays(ParticleData *particles){
    auto position = particles->getPos(access::location::gpu, access::mode::read);
    auto mass = particles->getMass(access::location::gpu, access::mode::read);
    return std::make_tuple(position.raw(), mass.raw());
  } //!
%! codeblockend !//
\end{lstlisting}
You might have asked yourself why we handed the position over to the force
function even though it doesn't need to know the particle's location. The reason,
you might have guessed, lies in the tuple function, which extracts information
from the \texttt{particles} information and sends the same arguments to both the
force and energy functions.

Imagine we pull the rope out to the right. In addition to the positions and
velocities, we must also define the mass of each element in the rope.
\begin{lstlisting}
%! codeblock: ropeInitialConditions
  {
    auto position
      = particles->getPos(access::location::cpu,
                          access::mode::write);
    auto velocity
      = particles->getVel(access::location::cpu,
                          access::mode::write);
    auto mass
      = particles->getMass(access::location::cpu,
                          access::mode::write);

    real ropeLength = 1.0;
    for(int i = 0; i < numberOfParticles; ++i) {
      position[i].x = i*(ropeLength/(numberOfParticles - 1));
      position[i].y = position[i].z = position[i].w = real(0.0);
      velocity[i].x = velocity[i].y = velocity[i].z = real(0.0);
      mass[i] = real(0.001);
    }
  } //!
%! codeblockend !//
\end{lstlisting}

It does not matter much whether you write the constant numerical values as 
\texttt{0.0} or \texttt{real(0.0)} here. I recommend you get used to the second 
option in UAMMD. It will help the compiler speed up your code by casting the 
floating point number to the right precision.

To create the gravitational interaction and add it to the integrator, follow the
standard procedure.
\begin{lstlisting}
%! codeblock: gravityInteraction
  {
    auto gravity
      = make_shared<ExternalForces<gravitationalForce>>(particles, sys, make_shared<gravitationalForce>(real(9.8)));

    integrator->addInteractor(gravity);
  } //!
%! codeblockend !//
\end{lstlisting}

Time for an important warning. If you want your code to compile with the changes
in this section, you must appease the spirits of \texttt{nvcc} with the flag
\texttt{--expt-relaxed-constexpr}.
\begin{lstlisting}
nvcc -I../uammd/src -I../uammd/src/third_party --expt-relaxed-constexpr -o swingingRope swingingRope.cu
\end{lstlisting}
as well as any other relevant options on your system. When all the pieces fit
together nicely, you should be able to reproduce Figure \ref{swingingRope}.

\begin{figure}[t]
  \centering
  \includegraphics[width = 0.6 \textwidth]{figures/swingingRope.eps}
  \caption{\label{swingingRope}A chain of $101$ particles connected with
           harmonic bonds attached to the origin behaves like a swinging rope
           in a gravitational field. \textit{Parameters}: time step
           $dt = 10^{-4}$, 15000 steps printing every 300 steps.}
\end{figure}


\begin{comment}
Swinging rope simulation code:
\begin{lstlisting}
%! codefile: code/swingingRope.cu
# include "uammd.cuh"
# include "utils/InitialConditions.cuh"
# include "Interactor/BondedForces.cuh"
# include "Interactor/ExternalForces.cuh"
# include "Integrator/VerletNVE.cuh"

using namespace uammd;
using std::make_shared;
using std::endl;

%! codeinsert: gravityDefinition

int main(int argc, char *argv[]){

  auto sys = make_shared<System>(argc, argv);

  int numberOfParticles = 101;
  auto particles
    = make_shared<ParticleData>(numberOfParticles, sys);

  %! codeinsert: ropeInitialConditions

  using Verlet = VerletNVE;
  Verlet::Parameters VerletParams;
  VerletParams.dt = real(0.0001);
  VerletParams.initVelocities=false;

  %! codeinsert: Verlet src: chapters/first_simulation.tex

  {
    std::ofstream bondInfo("data.bonds");
    if(not bondInfo.is_open()) {
      sys->log<System::CRITICAL>("Unable to create data.bonds file. Halting program.");
      exit(-1);
    }

    bondInfo<<(numberOfParticles - 1)<<endl;
    for(int i = 0; i < numberOfParticles - 1; ++i) {
      bondInfo<<i<<" "<<(i + 1)<<" 1000.0 0.01"<<endl;
    }
    bondInfo<<"1"<<endl;
    bondInfo<<"0 0 0 0 1000.0 0.0"<<endl;
  }

  %! codeinsert: stringBondInteractor

  %! codeinsert: stringAddInteractor

  %! codeinsert: gravityInteraction

  std::string outputFile = "swingingRope.dat";
  std::ofstream out(outputFile);

  int numberOfSteps = 15000;
  int printEverynSteps = 300;

  %! codeinsert: integrate

  sys->finish();

  return 0;
}
%! codeend
\end{lstlisting}
\end{comment}

\section{Other types of bonds}

Harmonic bonds thread points together easily, but some circumstances require
other specialised types of bonds. Take a polymer strand in solution and zoom in
on a section of a few hundred monomers. It may behave like a harmonic spring
when you try to stretch it, but it will not extend indefinitely without
breaking. Harmonic potentials, in contrast, allow you to stretch a bond
indefinitely as long as you pull hard enough.

In settings like polymer research you would prefer a finitely extensible
nonlinear  elastic (FENE) bond. FENE bonds have a potential function given by
\begin{equation*}
  V_\text{FENE}(r) = -\frac{1}{2} K r_0^2\ 
                \ln\left(1 - \left(\frac{r}{r_0}\right)^2\right).
\end{equation*}
Note that the minimum value for $V_\text{FENE}(r)$ (with $r \geq 0$) lies at $r 
= 0$, so the force will tend to pull the particles on top of each other. 
Customarily, researchers combine FENE bonds with the repulsive part of 
Lennard-Jones potentials (also known as Weeks-Chandler-Andersen or WCA 
potentials), making the interaction potential between two bonded particles equal 
to
\begin{equation*}
  V(r) =
    \begin{cases}
         V_\text{FENE}
         + \epsilon
         + 4\epsilon\left(\left(\frac{\sigma}{r}\right)^{12}
                        - \left(\frac{\sigma}{r}\right)^6\right),
         & \text{ for } r \leq \sqrt[6]{2} \sigma, \\
         V_\text{FENE}
         & \text{ for } r > \sqrt[6]{2} \sigma.
    \end{cases}
\end{equation*}
Furthermore, note that $V(r)$ diverges as $r$ approaches $r_0$. This guarantees
that particles will never separate farther than $r_0$ as long as you choose
small enough integration time steps.

Within UAMMD, code for FENE bonds parallels that of harmonic bonds, but with a
different type, so you would define them with
\begin{lstlisting}
    using FENEBonds = BondedForces<BondedType::FENE>;
\end{lstlisting}
When experimenting with FENE bonds, remember that linked particles must start
off with a separation smaller than $r_0$.

A different special case arises when modelling periodic structures. Picture an
infinite chain of particles stretching across the simulation box from left to
right. This we can simulate with periodic boundary conditions, but note that we
have to connect the leftmost particle not to the last particle on the right, but
rather to its periodic image to the left. Similarly, the particle closest to the
right of the box attaches to a periodic image of the first particle on the left.
Clearly, a bond crossing the whole width of the box will not do. We must specify
that a bond between particles $i$ and $j$ means between $i$ and the closest
periodic image of $j$ and viceversa. These types of bonds were named HarmonicPBC
and FENEPBC in UAMMD.

This chapter explains how to define your own bond types later on, after the
following section on angular potentials.

\section{Angular potentials}

How do you transform a rope into a flexible rod in UAMMD? Probably the easiest
route simply adds more bonds. Instead of connecting particles in a line only to
their nearest neighbours, connect them also to particles lying farther. This
approach is known as building an elastic network, and has many practical
applications.

Now imagine a molecule formed by atoms labelled $i$, $j$ and $k$, as in Figure
\ref{angularPotential}. Bonds connect particles $i$ and $j$, and particles $j$
and $k$. We could get the molecule to form the right angle $\theta$ by adding in
an extra bond between $i$ and $k$. If we wish to study the vibrations of our
molecule, we wouldn't usually employ that approach, though. Here's why. Forces
should tend to restore $\theta$ when the molecule undergoes a deformation that
changes this angle, but we can stretch the bond between $i$ and $k$ without
altering the angle $\theta$ by stretching the other two bonds in the the same
proportion. That would cause a force between $i$ and $k$ that should not be
there. Contrariwise, you can devise configurations with angles different from
$\theta$ while keeping the bond between $i$ and $k$ at the equilibrium length,
achieving a configuration where there is no force between $i$ and $k$ even
though there should be one. As a result, you get a molecule that doesn't wobble
as it should.

\begin{figure}
  \centering
  \includegraphics[width = 0.5 \textwidth]{figures/angularSprings.eps}
  \caption{\label{angularPotential}Angular potentials cause forces on a triplet
           of particles when the angle $\theta$ they form differs from some 
           established equilibrium angle.}
\end{figure}

We can set up \textit{angular} potentials indicating the labels of the three 
particles involved, $i$, $j$ and $k$, the rigidity $K$ and the equilibrium angle 
$\theta_0$. When the particles form an angle $\theta \neq \theta_0$, they feel a 
force that tends to restore $\theta$ back to $\theta_0$. The angular potentials 
file would start with the number of triplets on the first line, followed by rows 
in which you specify $i$, $j$, $k$, $K$ and $\theta_0$, in that order. So a file 
with two angular potentials could look like this:
\begin{lstlisting}
2
0 1 2 100 0
5 6 7 100 1.5708
\end{lstlisting}
The first three particles would tend to lie on a straight line, while particles 
$5$, $6$ and $7$ would form a right angle. Note that $\theta_0$ refers to the 
equilibrium angle between $\mathbf{r}_{ij}$ and $\mathbf{r}_{jk}$ (see Fig. 
\ref{angularPotential}).

With the sole intention of showing you how angular potentials work, we'll 
transform our rope in the previous code into something like a fiberglass cable, 
in that it opposes bending slightly.

For starters, we hold the inital tenth of the cable horizontally with
fixed-point bonds, and let gravity bend the rest of the cable.
\begin{lstlisting}
%! codeblock: cableFixedBonds
    bondInfo<<"10"<<endl;

    real cableLength = 1.0;
    for(int i = 0; i < 10; ++i)
      bondInfo<<i<<" "<<i*(cableLength/(numberOfParticles - 1))<<" 0 0 1000.0 0.0"<<endl; //!
%! codeblockend !//
\end{lstlisting}
We will need a smaller time step to resolve the motion.
\begin{lstlisting}
%! codeblock: cableTimeStep
  VerletParams.dt = real(0.00001); //!
%! codeblockend !//
\end{lstlisting}
Consequently, we increase the number of steps to integrate.
\begin{lstlisting}
%! codeblock: cableNumberOfSteps
  int numberOfSteps = 150000;
  int printEverynSteps = 5000; //!
%! codeblockend !//
\end{lstlisting}

Now let us link our chain with angular potentials, by attaching every three
consecutive particles with $K = 2.0$ and $\theta_0 = 0$.
\begin{lstlisting}
%! codeblock: angularForcesFile
  {
    std::ofstream angularInfo("data.angularForces");
    if(not angularInfo.is_open()) {
      sys->log<System::CRITICAL>("Unable to create data.angularForces file. Halting program.");
      exit(-1);
    }

    real K = 2.0, theta0 = 0.0;
    angularInfo<<(numberOfParticles - 2)<<endl;
    for(int i = 0; i < numberOfParticles - 2; ++i) {
      angularInfo<<i<<" "<<(i + 1)<<" "<<(i + 2)<<" "<<K<<" "<<theta0<<endl;
    }
  } //!
%! codeblockend !//
\end{lstlisting}

If we connect our UAMMD module to the relevant header,
\begin{lstlisting}
# include "Interactor/AngularBondedForces.cuh"
\end{lstlisting}
creating the interaction follows the usual rules, but notice that you need to
have a simulation box defined (as explained in section \ref{simulation_box}). We
will just make the box infinite in every direction.
\begin{lstlisting}
%! codeblock: cableBox
  real L = std::numeric_limits<real>::infinity();
  Box box(make_real3(L, L, L)); //!
%! codeblockend !//
\end{lstlisting}
To generate the angular forces interaction, we write code that parallels the
creation of harmonic bonds.
\begin{lstlisting}
%! codeblock: angularForces
  {
    using angularPotentials
      = AngularBondedForces<BondedType::Angular>;
    angularPotentials::Parameters angularParameters;
    angularParameters.file = "data.angularForces";
    auto angularForces
      = make_shared<angularPotentials>(particles, sys,
                                       angularParameters,
                                       std::make_shared<BondedType::Angular>(box));
    integrator->addInteractor(angularForces);
  } //!
%! codeblockend !//
\end{lstlisting}
I should briefly draw your attention to the last parameter in the creation of 
\texttt{angularForces}. For obscure design reasons that we do not care about 
now, the interactor takes a shared pointer to the bond type (or, alternatively, 
an instance) as an extra parameter.

\begin{comment}
The structure of the UAMMD module code for a flexible cable follows.
\begin{lstlisting}
%! codefile: code/cable.cu
# include "uammd.cuh"
# include "utils/InitialConditions.cuh"
# include "Interactor/BondedForces.cuh"
# include "Interactor/AngularBondedForces.cuh"
# include "Interactor/ExternalForces.cuh"
# include "Integrator/VerletNVE.cuh"

using namespace uammd;
using std::make_shared;
using std::endl;

%! codeinsert: gravityDefinition

int main(int argc, char *argv[]){

  auto sys = make_shared<System>(argc, argv);

  int numberOfParticles = 101;
  auto particles
    = make_shared<ParticleData>(numberOfParticles, sys);

  %! codeinsert: ropeInitialConditions

  %! codeinsert: cableBox

  using Verlet = VerletNVE;
  Verlet::Parameters VerletParams;
  %! codeinsert: cableTimeStep
  VerletParams.initVelocities=false;

  %! codeinsert: Verlet src: chapters/first_simulation.tex

  {
    std::ofstream bondInfo("data.bonds");
    if(not bondInfo.is_open()) {
      sys->log<System::CRITICAL>("Unable to create data.bonds file. Halting program.");
      exit(-1);
    }

    bondInfo<<(numberOfParticles - 1)<<endl;
    for(int i = 0; i < numberOfParticles - 1; ++i) {
      bondInfo<<i<<" "<<(i + 1)<<" 1000.0 0.01"<<endl;
    }
    %! codeinsert: cableFixedBonds
  }

  %! codeinsert: angularForcesFile

  %! codeinsert: stringBondInteractor

  %! codeinsert: stringAddInteractor

  %! codeinsert: angularForces

  %! codeinsert: gravityInteraction

  std::string outputFile = "cable.dat";
  std::ofstream out(outputFile);

  %! codeinsert: cableNumberOfSteps

  %! codeinsert: integrate

  sys->finish();

  return 0;
}
%! codeend
\end{lstlisting}
\end{comment}

\begin{figure}
  \centering
  \includegraphics[width = 0.6 \textwidth]{figures/cable.eps}
  \caption{\label{cable}101 particles simulating a flexible cable bending under 
           its own weight. The tenth of the cable closest to the origin was held
           in place with fixed-point bonds.}
\end{figure}

Figure \ref{cable} shows the result of running the cable program. When compared
to Figure \ref{swingingRope}, you can clearly see we have increased our chain's
aversion to bending.

We're not yet done with angular potentials, though. Look at the molecule in 
Figure \ref{torsionalSprings}. There, we could set up angular forces that
restored the angle between $\mathbf{r}_{ij}$ and $\mathbf{r}_{jk}$, and between
$\mathbf{r}_{jk}$ and $\mathbf{r}_{kl}$. However, $\mathbf{r}_{kl}$ would still 
swivel freely around the axis going through $\mathbf{r}_{jk}$, unless we define
some potential that opposes the torsion of this molecule. This we can achieve
with the torsional forces interaction.
\begin{lstlisting}
# include "Interactor/TorsionalBondedForces.cuh"
\end{lstlisting}

\begin{figure}
  \centering
  \includegraphics[width = 0.6 \textwidth]{figures/torsionalSprings.eps}
  \caption{\label{torsionalSprings}Torsional potentials oppose torsion. In the
           diagram above, a torsional potential would act to restore the
           equilibrium value of $\phi$, the angle formed between the plane
           shared by particles $i$, $j$ and $k$, and the plane shared by $j$,
           $k$ and $l$.}
\end{figure}

It will not surprise you to learn that the file format for torsional forces
begins with the number of quartets followed by rows of $i$, $j$, $k$, $l$, $K$
and $\phi_0$ for each relevant torsion angle.

With a few changes to our cable code we'll simulate a curly wire. To simplify
our code slightly, we leave out gravity and fixed-point bonds. In consequence,
we must provide some curvature. Otherwise, the chain will remain stretched out
in a state of unstable equilibrium. We will add in a slight torsion as well, to
bias the torsional forces.
\begin{lstlisting}
%! codeblock: wireInitialConditions
  {
    auto position
      = particles->getPos(access::location::cpu,
                          access::mode::write);
    auto velocity
      = particles->getVel(access::location::cpu,
                          access::mode::write);

    real wireLength = 1.0;
    for(int i = 0; i < numberOfParticles; ++i) {
      position[i].x
        = wireLength/(2*M_PI)*cos(2*M_PI*i/(numberOfParticles - 1));
      position[i].y
        = wireLength/(2*M_PI)*sin(2*M_PI*i/(numberOfParticles - 1));
      position[i].z = 0.0001*i;
      position[i].w = 0;
      velocity[i].x = velocity[i].y = velocity[i].z = 0;
    }
  } //!
%! codeblockend !//
\end{lstlisting}
Soften the angular forces and set the curvature of the chain with
\begin{lstlisting}
%! codeblock: wireCurvature
    real K = 1.0, theta0 = 4*M_PI/(numberOfParticles - 1); //!
%! codeblockend !//
\end{lstlisting}
Now for the torsional potentials connecting every four sequential points.
\begin{lstlisting}
%! codeblock: torsionalForcesFile
  {
    std::ofstream torsionalInfo("data.torsionalForces");
    if(not torsionalInfo.is_open()) {
      sys->log<System::CRITICAL>("Unable to create data.torsionalForces file. Halting program.");
      exit(-1);
    }

    real K = 0.1, phi0 = 0.01;
    torsionalInfo<<(numberOfParticles - 3)<<endl;
    for(int i = 0; i < numberOfParticles - 2; ++i) {
      torsionalInfo<<i<<" "<<(i + 1)<<" "<<(i + 2)<<" "<<(i + 3)
                   <<" "<<K<<" "<<phi0<<endl;
    }
  } //!
%! codeblockend !//
\end{lstlisting}
Torsion interactors replicate the structure of the angular interaction code
written above.
\begin{lstlisting}
%! codeblock: torsionalForces
  {
    using torsionalPotentials
     = TorsionalBondedForces<BondedType::Torsional>;
    torsionalPotentials::Parameters torsionalParameters;
    torsionalParameters.file = "data.torsionalForces";
    auto torsionalForces
     = make_shared<torsionalPotentials>(particles, sys,
                                        torsionalParameters,
                                        std::make_shared<BondedType::Torsional>(box));
    integrator->addInteractor(torsionalForces);
  } //!
%! codeblockend !//
\end{lstlisting}
This time, I carried out a longer time integration.
\begin{lstlisting}
%! codeblock: wireNumberOfSteps
  int numberOfSteps = 600000;
  int printEverynSteps = 10000; //!
%! codeblockend !//
\end{lstlisting}

\begin{figure}
  \centering
  \includegraphics[width = \textwidth]{figures/curlyWire.eps}
  \caption{\label{curlyWire}Top and side view of the final state of the curly
           wire simulation (dark solid line). The dashed line marks the initial
           state of the wire, while the grey line presents the final state when
           you deactivate the torsional potentials.}
\end{figure}

Figure \ref{curlyWire} compares the initial and final state of the wire after
running the simulation. Not only does the wire curl up, it also moves in the
direction perpendicular to the $xy$ plane. Deactivating the torsional forces
leads to a completely different outcome, of course.

\begin{comment}
The structure of the UAMMD module code for a curled wire follows.
\begin{lstlisting}
%! codefile: code/curlyWire.cu
# include "uammd.cuh"
# include "utils/InitialConditions.cuh"
# include "Interactor/BondedForces.cuh"
# include "Interactor/AngularBondedForces.cuh"
# include "Interactor/TorsionalBondedForces.cuh"
# include "Integrator/VerletNVE.cuh"

using namespace uammd;
using std::make_shared;
using std::endl;

int main(int argc, char *argv[]){

  auto sys = make_shared<System>(argc, argv);

  int numberOfParticles = 101;
  auto particles
    = make_shared<ParticleData>(numberOfParticles, sys);

  %! codeinsert: wireInitialConditions

  %! codeinsert: cableBox

  using Verlet = VerletNVE;
  Verlet::Parameters VerletParams;
  %! codeinsert: cableTimeStep
  VerletParams.initVelocities=false;

  %! codeinsert: Verlet src: chapters/first_simulation.tex

  {
    std::ofstream bondInfo("data.bonds");
    if(not bondInfo.is_open()) {
      sys->log<System::CRITICAL>("Unable to create data.bonds file. Halting program.");
      exit(-1);
    }

    bondInfo<<(numberOfParticles - 1)<<endl;
    for(int i = 0; i < numberOfParticles - 1; ++i) {
      bondInfo<<i<<" "<<(i + 1)<<" 1000.0 0.01"<<endl;
    }
  }

  {
    std::ofstream angularInfo("data.angularForces");
    if(not angularInfo.is_open()) {
      sys->log<System::CRITICAL>("Unable to create data.angularForces file. Halting program.");
      exit(-1);
    }

    %! codeinsert: wireCurvature
    angularInfo<<(numberOfParticles - 2)<<endl;
    for(int i = 0; i < numberOfParticles - 2; ++i) {
      angularInfo<<i<<" "<<(i + 1)<<" "<<(i + 2)<<" "<<K<<" "<<theta0<<endl;
    }
  }

  %! codeinsert: torsionalForcesFile

  %! codeinsert: stringBondInteractor

  %! codeinsert: stringAddInteractor

  %! codeinsert: angularForces

  %! codeinsert: torsionalForces

  std::string outputFile = "curlyWire.dat";
  std::ofstream out(outputFile);

  %! codeinsert: wireNumberOfSteps

  %! codeinsert: integrate

  sys->finish();

  return 0;
}
%! codeend
\end{lstlisting}
\end{comment}

\section{Custom bonds}

At least in theory, neither harmonic nor FENE bonds break, no matter how hard
you pull on them. In contrast, the Morse potential, used to model diatomic
molecules and some polymer chains, does allow linked particles to break free.
UAMMD has no default Morse bond potential, so let me implement it for you, and 
you'll see how to create your own bonds.

Like Harmonic bonds, the Morse potential depends on the distance $r$ between 
bonded particles, but three parameters determine its shape, instead of two.
\begin{equation*}
  V(r) = D_e\left(\left(e^{-a(r - r_0)} - 1\right)^2 - 1\right).
\end{equation*}
$D_e$ marks the depth of the potential, $a$ determines its width, and $r_0$ the
equilibrium distance. As we did with gravity, we create a new data structure
before \texttt{main}, opening with
\begin{lstlisting}
%! codeblock: MorsePotential
struct Morse { //!
%! codeinsert: MorseParameters
%! codeinsert: MorseReadBonds
%! codeinsert: MorseEnergy
%! codeinsert: MorseForce
%! codeblockend !//
\end{lstlisting}
The data structure must contain four items:
\begin{enumerate}
  \item A list of the parameter variables that define the bond, packed into a
        data structure.
  \item A function detailing how to read the bond parameter values from a file.
  \item A function for the energy as a function of the inter-particle 
        separation.
  \item The force due to the interaction.
\end{enumerate}
The item at the top of the list would come out as follows:
\begin{lstlisting}
%! codeblock: MorseParameters
  struct BondInfo {
    real De, a, r0;
  }; //!
%! codeblockend !//
\end{lstlisting}
In the file listing the bonds, we would like to begin with the number of bonds,
followed by rows of $i$, $j$, $D_e$, $a$, and $r0$, by analogy with previous
bond data. UAMMD assumes this layout, but does not know how many parameters you
will need to read for your particular type of bond, nor the right order. This we
specify in a \texttt{readBond} function.
\begin{lstlisting}
%! codeblock: MorseReadBonds
  static __host__ BondInfo readBond(std::istream &in) {
    BondInfo MorseParams;
    in>>MorseParams.De>>MorseParams.a>>MorseParams.r0;
    return MorseParams;
  } //!
%! codeblockend !//
\end{lstlisting}
The energy function calculates $V(r)$, according to the aforementioned Morse
potential, but returns only half this value. That means that the particle at
each side of the bond stores one half of the energy in the bond they share.
\begin{lstlisting}
%! codeblock: MorseEnergy
  __device__ real energy(int i, int j, real3 rji,
                                BondInfo MorseParams) {
    real r = sqrtf(dot(rji, rji));
    real oneminusexpar
      = real(1.0) - exp(-MorseParams.a*(r - MorseParams.r0));
    real Vij = MorseParams.De*(oneminusexpar*oneminusexpar - real(1.0));
    return real(0.5)*Vij;
  } //!
%! codeblockend !//
\end{lstlisting}
The \texttt{rji} variable represents the vector
$\mathbf{r}_{ji} = \mathbf{r}_i - \mathbf{r}_j$ pointing at particle $i$ (for
which we wish to calculate the energy) from particle $j$ on the other side of
the bond.

Finally, we close our \texttt{Morse} data structure with the force, which equals
the negative gradient of the energy,
\begin{equation*}
  \mathbf{F}(\mathbf{r})
    = -\nabla V(r)
    = 2 D_e a \left(e^{-a(r - r_0)} - 1\right)
              e^{-a(r - r0)}\ \frac{\mathbf{r}}{r}.
\end{equation*}
\begin{lstlisting}
%! codeblock: MorseForce
  __device__ real3 force(int i, int j, real3 rji,
                                BondInfo MorseParams) {
    real r = sqrtf(dot(rji, rji));
    real expar = exp(-MorseParams.a*(r - MorseParams.r0));
    return real(2.0)*MorseParams.De*MorseParams.a
                    *((expar - 1)*expar/r)*rji;
  }
}; //!
%! codeblockend !//
\end{lstlisting}

To incorporate our new interaction, proceed as with the Harmonic bonds, but
replacing the \texttt{BondedType::Harmonic} with our \texttt{Morse}.
\begin{lstlisting}
%! codeblock: MorseInteraction
  {
    using MorseBonds = BondedForces<Morse>;
    MorseBonds::Parameters bondParameters;
    bondParameters.file = "data.bonds";
    auto bonds = make_shared<MorseBonds>(particles, sys,
                                         bondParameters);

    integrator->addInteractor(bonds);
  } //!
%! codeblockend !//
\end{lstlisting}

As a test, I swapped the bonds in the swinging rope simulation with our newer 
design. I had to remember to change the data written to the \texttt{data.bonds} 
file.
\begin{lstlisting}
%! codeblock: MorseBondFile
    real De = 0.025, a = 200.0, r0 = 0.01;
    bondInfo<<(numberOfParticles - 1)<<endl;
    for(int i = 0; i < numberOfParticles - 1; ++i) {
      bondInfo<<i<<" "<<(i + 1)<<" "
              <<De<<" "<<a<<" "<<r0<<endl;
    }
    bondInfo<<"1"<<endl;
    bondInfo<<"0 0 0 0 "<<De<<" "<<a<<" "<<r0<<endl; //!
%! codeblockend !//
\end{lstlisting}
Written in this way, the simulation would still not work because of particle 
$0$, which begins at the origin, making $r = 0$ for the fixed-point bond. This
made the code divide by zero, outputting a \texttt{nan} (\textit{not a number})
that caused an avalanche of \texttt{nan}s in the computations. To avoid the
problem, I began with the whole chain shifted slightly to the right.
\begin{lstlisting}
%! codeblock: MorseChainInitialConditions
      position[i].x = (1 + i)*(ropeLength/(numberOfParticles - 1)); //!
%! codeblockend !//
\end{lstlisting}
Of course, this does not prevent particles from overlapping later on in the 
simulation. If you wished to carry out serious work with Morse bonds, you should 
handle the $\|\mathbf{r}\| = 0$ case separately. For the energy, for example, 
after calculating \texttt{real r = sqrtf(dot(rji, rji))} you could deal with
overlap by writing
\begin{lstlisting}
    if(r == 0) return real(0.0);
\end{lstlisting}
and similarly for the force (but returning a \texttt{real3} zero vector).

\begin{figure}
  \centering
  \includegraphics[width = 0.6 \textwidth]{figures/MorseChain.eps}
  \caption{\label{MorseChain} A chain of particles linked and attached to the 
           origin with Morse potentials swings under its own weight and ends up 
           breaking off and falling (\textit{time step}: $10^{-5}$, 
           $1.5 \times 10^5$ steps, printing out every $5 \times 10^3$).}
\end{figure}

When the simulation runs, the fixed-point bond snaps as the chain of particles
swings around (Figure \ref{MorseChain}). 

\begin{comment}
The Morse chain code copies swingingRope.cu, with the few changes indicated 
above.
\begin{lstlisting}
%! codefile: code/MorseChain.cu
# include "uammd.cuh"
# include "utils/InitialConditions.cuh"
# include "Interactor/BondedForces.cuh"
# include "Interactor/ExternalForces.cuh"
# include "Integrator/VerletNVE.cuh"

using namespace uammd;
using std::make_shared;
using std::endl;

%! codeinsert: MorsePotential

%! codeinsert: gravityDefinition

int main(int argc, char *argv[]){

  auto sys = make_shared<System>(argc, argv);

  int numberOfParticles = 101;
  auto particles
    = make_shared<ParticleData>(numberOfParticles, sys);

  {
    auto position
      = particles->getPos(access::location::cpu,
                          access::mode::write);
    auto velocity
      = particles->getVel(access::location::cpu,
                          access::mode::write);
    auto mass
      = particles->getMass(access::location::cpu,
                          access::mode::write);

    real ropeLength = 1.0;
    for(int i = 0; i < numberOfParticles; ++i) {
      %! codeinsert: MorseChainInitialConditions
      position[i].y = position[i].z = position[i].w = real(0.0);
      velocity[i].x = velocity[i].y = velocity[i].z = real(0.0);
      mass[i] = real(0.001);
    }
  }

  using Verlet = VerletNVE;
  Verlet::Parameters VerletParams;
  VerletParams.dt = real(0.00001);
  VerletParams.initVelocities=false;

  %! codeinsert: Verlet src: chapters/first_simulation.tex

  {
    std::ofstream bondInfo("data.bonds");
    if(not bondInfo.is_open()) {
      sys->log<System::CRITICAL>("Unable to create data.bonds file. Halting program.");
      exit(-1);
    }

    %! codeinsert: MorseBondFile
  }

  %! codeinsert: MorseInteraction

  %! codeinsert: gravityInteraction

  std::string outputFile = "MorseChain.dat";
  std::ofstream out(outputFile);

  int numberOfSteps = 150000;
  int printEverynSteps = 5000;

  %! codeinsert: integrate

  sys->finish();

  return 0;
}
%! codeend
\end{lstlisting}
\end{comment}

\section{\label{Custom_pair_potentials}Custom pair potentials}

Our definition of Morse bond potentials describes the phenomenon of
dissociation, but we wouldn't use it to produce bond formation. Particles $i$
and $j$ would only link if the connection had been listed already in the
\texttt{data.bonds} file. To allow bonds to form between any two candidate
particles, we would be much better off coding the Morse potential as a pair
interaction.

Starting from our Lennard-Jones code written in the previous chapter, let us 
replace the pair potential with a Morse interaction. We will again capture the
interaction within a data structure, beginning with the parameters and a 
constructor to assign their values. Before the main function, we write the 
following.
\begin{lstlisting}
%! codeblock: MorsePairPotential
struct Morse {
  real De, a, r0, rc;

  Morse(real i_De, real i_a, real i_r0, real i_rc):
       De(i_De), a(i_a), r0(i_r0), rc(i_rc){} //!
  %! codeinsert: getCutOff
  %! codeinsert: ForceEnergy
  %! codeinsert: getTransverser
%! codeblockend !//
\end{lstlisting}
Pair potentials must include a function called \texttt{getCutOff} that returns
the range of the potential interaction.
\begin{lstlisting}
%! codeblock: getCutOff
  real getCutOff() { return rc; } //!
%! codeblockend !//
\end{lstlisting}

Next, we come to our first definition of a \textit{transverser}, a key concept 
in the UAMMD infrastructure, named after the action of traversing a list to 
transform data (the word \textit{traverser} apparently didn't sound cool enough, 
though). You'll understand the idea easily. For each particle, we wish to apply 
a function to each particle-neighbour pair. In this case, we wish to compute the 
force and energy due to the interactions of a particle with each of its 
neighbours.

We'll define our transverser as a data structure that begins setting the values
of the parameters.
\begin{lstlisting}
%! codeblock: ForceEnergy
  struct ForceEnergy {
    real4 * force;
    real * energy;
    Box box;
    real De, a, r0, rc;

    ForceEnergy(Box i_box, real i_rc,
                real4 * i_force, real * i_energy,
                real i_De, real i_a, real i_r0):
                box(i_box), rc(i_rc),
                force(i_force), energy(i_energy),
                De(i_De), a(i_a), r0(i_r0){} //!
    %! codeinsert: compute_and_set
%! codeblockend !//
\end{lstlisting}
It ends with two functions, one computes the force and energy for each pair 
interaction, according to the Morse potential, and the other specifies what to 
do with the results.
\begin{lstlisting}
%! codeblock: compute_and_set
    __device__ real4 compute(real4 ri, real4 rj){
      const real3 rij = box.apply_pbc(make_real3(rj)-make_real3(ri));
      const real r2 = dot(rij, rij);
      const real r = sqrtf(r2);
      if(r2 > 0 and r < rc){
        const real expar = exp(-a*(r - r0));
        const real oneminusexpar = real(1.0) - expar;
        return make_real4(2.0*De*a*(oneminusexpar*expar/r)*rij,
                          De*(oneminusexpar*oneminusexpar - real(1.0)));
      }
      return real4();
    }

    __device__ void set(int id, real4 total){
      force[id] += make_real4(total.x, total.y, total.z, 0);
      energy[id] += real(0.5)*total.w;
    }
  }; //!
%! codeblockend !//
\end{lstlisting}
Once again, note that in \texttt{set} we add only half of the potential energy
calculated above to the energy per particle stored in \texttt{particleData}.
The interaction energy between particles $i$ and $j$ belongs to the pair, but
we store it twice, once for $i$ and once for $j$. By saving only half the value 
per interaction, we get the correct total by adding up the whole energy vector.

UAMMD includes additional functions designed to tweak the behaviour of your 
transversers, but we won't need them for the time being.

I must stop here to warn you that UAMMD considers a particle neighbour of 
itself, so you must always remember to handle the special case where $i$ and $j$ 
both refer to the same particle. The code above deals with this case by stating 
that the force and energy vanish when the distance from $i$ to $j$ equals zero, 
or more precisely, the force differs from zero only when $\|\mathbf{r}_{ij}\|^2 
> 0$ but $\|\mathbf{r}_{ij}\|^2 < r_c$.

Finally, the containing \texttt{Morse} structure ends with a function that 
returns the \texttt{ForceEnergy} transverser just defined, setting the values of 
the parameters and the references to the force and energy lists.
\begin{lstlisting}
%! codeblock: getTransverser
  ForceEnergy getForceEnergyTransverser(Box box,
                             std::shared_ptr<ParticleData> sys){
    auto force = sys->getForce(access::location::gpu,
                               access::mode::readwrite).raw();
    auto energy = sys->getEnergy(access::location::gpu,
                                 access::mode::readwrite).raw();
    return ForceEnergy(box, rc, force, energy, De, a, r0);
  }
}; //!
%! codeblockend !//
\end{lstlisting}

That defined a new pair potential. You can probably imagine what comes next.
Adding the new interaction to the Verlet integrator follows the usual rules.
\begin{lstlisting}
%! codeblock: addMorsePairPotential
  real De = 1.0;
  real a = 2.0;
  real r0 = 1.0;
  real rc = 6.5*r0;

  auto MorsePotential = make_shared<Morse>(De, a, r0, rc);
  {
    using MorseForces = PairForces<Morse>;
    MorseForces::Parameters interactionParams;
    interactionParams.box = box;

    auto interaction
      = make_shared<MorseForces>(particles, sys,
                              interactionParams,
                              MorsePotential);

    integrator->addInteractor(interaction);
  } //!
%! codeblockend !//
\end{lstlisting}

\begin{comment}
The Morse interaction module replicates the Lennard-Jones code from chapter one,
replacing the interaction with the Morse potential defined in this section.
\begin{lstlisting}
%! codefile: code/Morse.cu
# include "uammd.cuh"
# include "utils/InitialConditions.cuh"
# include "Interactor/Potential/Potential.cuh"
# include "Interactor/NeighbourList/CellList.cuh"
# include "Interactor/PairForces.cuh"
# include "Integrator/VerletNVE.cuh"

using namespace uammd;
using std::make_shared;
using std::endl;

%! codeinsert: MorsePairPotential

int main(int argc, char *argv[]){

  auto sys = make_shared<System>(argc, argv);

  %! codeinsert: particleData src: chapters/first_simulation.tex

  %! codeinsert: latticeInitialConditions src: chapters/first_simulation.tex

  %! codeinsert: VerletParams src: chapters/first_simulation.tex

  %! codeinsert: Verlet src: chapters/first_simulation.tex

  %! codeinsert: addMorsePairPotential

  std::string outputFile = "Morse.dat";
  std::ofstream out(outputFile);

  int numberOfSteps = 1000;
  int printEverynSteps = 100;

  %! codeinsert: integration src: chapters/first_simulation.tex

  sys->finish();

  return 0;
}
%! codeend
\end{lstlisting}
\end{comment}

Our new potential can form and break bonds, but readers eager to embark 
enthusiastically on investigations of computational chemistry should first read 
the following section.

\section{The curve-hopping problem}

To describe the formation of chemical bonds, you would typically use quantum 
mechanics, sofisticated algorithms and costly computations. For the sake of 
argument, let us assume that you can get by in your investigation with a 
classical model, and that you decide to use UAMMD.

Suppose you wanted to model a diatomic gas. The atoms bond through a Morse 
potential, and collide and mix, creating and destroying bonds. The problem here 
comes from the fact that molecules contain at most two atoms. Unfortunately, our 
Morse pair potential can't preclude the formation of chains or clusters. To 
solve the issue, we would need a potential-switching algorithm. When particles 
form a bond, they should interact with their partner through the Morse 
potential, but react to every other particle with a Lennard-Jones force, for 
example. This might not seem like a big deal at first but you'll see that a few 
difficulties crop up.

Simply insert an \texttt{if} instruction in the calculation of the potential,
you say? If a bond exists between particles, use the Morse potential, otherwise 
apply the Lennard-Jones function. Yes, of course, but how do you decide when to 
bind particles together? This requires a decent amount of bookkeeping. Let's set 
up a list of bonds with as many entries as particles. We'll mark unbound 
particles with $-1$ and bound particles with the other particle's ID. Hence, 
if particle 0 were free and particle 1 were bound to particle 2, we would have
\texttt{bonds[0] = -1}, \texttt{bonds[1] = 2} and \texttt{bonds[2] = 1}. Bonds 
will dissolve as soon as the particles separate farther than the cut-off radius.

Quite straightforward, but hang on. Let us discuss bond formation first. Let two 
particles bind when they lie within the cut-off range without being already 
connected to some other particle. This means that as soon as you decide to link 
particles $i$ and $j$, they cease to count as candidate partners for others. A 
na\"ive parallel implementation of this condition will lead to inconsistencies 
because two nearby particles might try to bond to a third at the same time. We 
therefore need a new algorithm to deal with bond creation.

We're not done yet, though. When a bond breaks, the atoms involved will try to 
form new ones and will sometimes encounter other atoms already within bonding 
range. Consequently, their mutual energy will switch from the Lennard-Jones to 
the Morse potential in a sudden unjustified jump of the mechanical energy. To 
compensate for the difference, we can adjust the speeds of the newly linked 
atoms, transforming the difference in potential energy into kinetic energy.

With the project laid out before us, we inevitably have to face the question of 
whether it's worth the effort. UAMMD might provide a significant improvement in 
speed, but only if we come up with efficient algorithms dealing with the bonds. 
If you trust your theoretical knowledge and programming skills enough to carry 
out such a feat, then I believe you should seriously consider learning some CUDA 
and writing your simulation from scratch. Remember the open source nature of 
UAMMD. You can always copy whatever code you find useful there.

In the spirit of keeping this introduction as painless as possible, I will write 
a very inefficient but simpler simulation for our diatomic molecules. The 
program, as presented below, ran for days on my home computer, even though I 
lowered the number of particles to only one thousand.
\begin{lstlisting}
%! codeblock: diatomicParticleData
  int numberOfParticles = 1000;
  auto particles
    = make_shared<ParticleData>(numberOfParticles, sys); //!
%! codeblockend !//
\end{lstlisting}
I also decreased the initial energies, to avoid atoms slamming into each other.
\begin{lstlisting}
%! codeblock: diatomicInitialEnergy
  VerletParams.energy = 0.001; //!
%! codeblockend !//
\end{lstlisting}
After the initialisation of positions, we set the values of the atomic masses 
(as we will need them to adjust the speeds after any potential curve hopping).
\begin{lstlisting}
%! codeblock: diatomicSetMass
{
    auto mass
      = particles->getMass(access::location::cpu,
                           access::mode::write);
    real atomicMass = 1.0;
    std::fill(mass.begin(), mass.end(), atomicMass);
} //!
%! codeblockend !//
\end{lstlisting}
Finally, before we turn to writing the new pair potential, let us update the 
code that adds it to the integrator. Now we will obviously have to provide the 
extra parameters \texttt{sigma} and \texttt{epsilon} for the Lennard-Jones 
forces.
\begin{lstlisting}
%! codeblock: addDiatomicPairPotential
  real De = 1.0;
  real a = 2.0;
  real r0 = 1.0;
  real sigma = 1.0;
  real epsilon = 1.0;
  real rc = 6.5*r0;

  auto diatomicPotential
   = make_shared<diatomic>(De, a, r0, sigma, epsilon, rc, box);
  {
    using diatomicForces = PairForces<diatomic>;
    diatomicForces::Parameters interactionParams;
    interactionParams.box = box;

    auto interaction
      = make_shared<diatomicForces>(particles, sys,
                                    interactionParams,
                                    diatomicPotential);

    integrator->addInteractor(interaction);
  }

  std::string outputFile = "diatomic.dat";
  std::ofstream out(outputFile);

  int numberOfSteps = 100000;
  int printEverynSteps = 100; //!
%! codeblockend !//
\end{lstlisting}
Furthermore, before UAMMD calculates the interactions, it has to work out where 
to place the bonds. Right above the call to \texttt{integrator->forwardTime()}, 
we'll add a call to a function that we will write later on.
\begin{lstlisting}
%! codeblock: createDiatomicBonds
    diatomicPotential->createBonds(particles, sys); //!
%! codeblockend !//
\end{lstlisting}

That concludes the changes to the main function in our Morse pair potential 
simulations. We still have a few pages of code ahead, though. The definition of 
our new potential must incorporate variables for the Lennard-Jones force 
parameters. Let us change the head of the Morse potential to the following 
lines.
\begin{lstlisting}
%! codeblock: diatomicVariables
struct diatomic {
  real De, a, r0, rc;
  real sigma, epsilon;
  Box box;
  thrust::device_vector<int> bonds; //!
%! codeblockend !//
\end{lstlisting}
The \texttt{bonds} vector will contain the list of partner ID numbers mentioned 
above, with \texttt{-1} standing for no bond. The \texttt{getCutOff} obviously 
needs no changes, but the constructor should include the new parameter values.
\begin{lstlisting}
%! codeblock: diatomicConstructor
  diatomic(real i_De, real i_a, real i_r0,
           real i_sigma, real i_epsilon,
           real i_rc, Box i_box):
       De(i_De), a(i_a), r0(i_r0),
       sigma(i_sigma), epsilon(i_epsilon),
       rc(i_rc), box(i_box) {} //!
%! codeblockend !//
\end{lstlisting}
Now we can write a function to sort out the bonds. Assume that the simulation 
begins without bonds. We resize the bonds vector to the number of particles and 
fill it with negative values. This call will only have an effect the first time 
around because we won't change the number of particles.
\begin{lstlisting}
%! codeblock: diatomicCreateBonds
  void createBonds(std::shared_ptr<ParticleData> particles,
                   std::shared_ptr<System> sys){

    int numberOfParticles = particles->getNumParticles();

    bonds.resize(numberOfParticles, -1);
    int * bondlist = thrust::raw_pointer_cast(bonds.data()); //!
    %! codeinsert: diatomicParticleInfo
    %! codeinsert: diatomicBreakBonds
    %! codeinsert: diatomicFormBonds
%! codeblockend !//
\end{lstlisting}
The \texttt{createBonds} function needs information from particleData: the
positions, velocities, masses, ID numbers and indices.
\begin{lstlisting}
%! codeblock: diatomicParticleInfo
  	{
      auto position
        = particles->getPos(access::location::cpu,
                            access::mode::read);
      auto velocity
        = particles->getVel(access::location::cpu,
                            access::mode::readwrite);
      auto mass
        = particles->getMass(access::location::cpu,
                             access::mode::read);
      auto id
        = particles->getId(access::location::cpu,
                           access::mode::read);
      auto index
        = particles->getIdOrderedIndices(access::location::cpu); //!
%! codeblockend !//
\end{lstlisting}
Now we will look for broken bonds, that is, linked particles that have separated 
farther than $r_c$. If they have strayed enough from each other, we set their
bond indices to $-1$.
\begin{lstlisting}
%! codeblock: diatomicBreakBonds
      for(int i = 0; i < numberOfParticles; ++i) {
        int j = bonds[id[i]];
        if(j >= 0) {
          const real3 rij
            = box.apply_pbc(make_real3(position[index[j]])
                            - make_real3(position[i]));
          const real r2 = dot(rij, rij);
          if(r2 > rc*rc) {
            bonds[j] = bonds[id[i]] = -1;
          }
        }
      } //!
%! codeblockend !//
\end{lstlisting}
You should find the loop above easy enough to understand and, with some basic 
knowledge of CUDA, easy to parallelise.

The following chunk of code works out bond formation. It presents the simplest 
way that I can think of to bind particles without generating inconsistencies. 
Unfortunately, simplicity comes at the cost of being terribly inefficient. If 
you ever wanted to use this example for a serious simulation, the following 
section should be the first to improve. Neighbour lists algorithms provide an 
excellent way to speed up the calculations, but explaining how they work here 
would lead us too far astray.

The double loop below inspects all pairs of unbound particles and derives the 
(squared) distance between them.
\begin{lstlisting}
%! codeblock: diatomicFormBonds
      for(int i = 0; i < numberOfParticles - 1; ++i) {
        if(bonds[id[i]] >= 0) continue;
        const real3 ri = make_real3(position[i]);
        for(int j = i + 1; j < numberOfParticles; ++j) {
          if(bonds[id[j]] >= 0) continue;
          const real3 rij
            = box.apply_pbc(make_real3(position[j]) - ri);
          const real r2 = dot(rij, rij); //!
  %! codeinsert: diatomicLinkAtoms
  %! codeinsert: diatomicCurveHopping
%! codeblockend !//
\end{lstlisting}
As soon as it finds particles within the right range, it links them.
\begin{lstlisting}
%! codeblock: diatomicLinkAtoms
          if(r2 <= rc*rc) {
            bonds[id[j]] = id[i];
            bonds[id[i]] = id[j]; //!
%! codeblockend !//
\end{lstlisting}
The \texttt{createBonds} function ends by working out the difference in 
potential energy due to the curve hopping and adjusting the velocitites in such 
a way that the system conserves the total energy and linear momentum.
\begin{lstlisting}
%! codeblock: diatomicCurveHopping
            const real r = sqrtf(r2);
            const real expar = exp(-a*(r - r0));
            const real oneminusexpar = real(1.0) - expar;
            const real invr2 = (sigma*sigma)/r2;
            const real invr6 = invr2*invr2*invr2;
            const real deltaE = 4*epsilon*invr6*(invr6 - real(1.0))
                                - De*(oneminusexpar*oneminusexpar - real(1.0));
            if(deltaE >= 0) {
              velocity[i] += sqrtf(deltaE/mass[i])*rij/r;
              velocity[j] -= sqrtf(deltaE/mass[j])*rij/r;
            } else {
              velocity[i] -= sqrtf(-deltaE/mass[i])*rij/r;
              velocity[j] += sqrtf(-deltaE/mass[j])*rij/r;
            }
            break;
          }
        }
      }
    }
  } //!
%! codeblockend !//
\end{lstlisting}

We still have to write the \texttt{ForceEnergy} transverser and its associated
method. The first of these requires much more information than in the previous
section.
\begin{lstlisting}
%! codeblock: diatomicForceEnergy
  struct ForceEnergy{
    real4 * force;
    real * energy;
    Box box;
    real De, a, r0, rc;
    real sigma, epsilon;
    int * bondlist;
    int * id;

    ForceEnergy(Box i_box, real i_rc,
                real4 * i_force, real * i_energy,
                real i_De, real i_a, real i_r0,
                real i_sigma, real i_epsilon,
                int * i_bondlist, int * i_id):
                box(i_box), rc(i_rc),
                force(i_force), energy(i_energy),
                De(i_De), a(i_a), r0(i_r0),
                sigma(i_sigma), epsilon(i_epsilon),
                bondlist(i_bondlist), id(i_id){} //!
  %! codeinsert: diatomicGetInfo
  %! codeinsert: diatomicCompute
%! codeblockend !//
\end{lstlisting}
In this case, we cannot compute the forces and energies exclusively from the 
particle positions. We also need to know the particle IDs to identify linked
atoms and choose the right potential. To solve the problem, we include a 
function named \texttt{getInfo} which reads the particle index and returns its 
ID.
\begin{lstlisting}
%! codeblock: diatomicGetInfo
    __device__ int getInfo(int index){
      return id[index];
    } //!
%! codeblockend !//
\end{lstlisting}
UAMMD will feed the output of \texttt{getInfo} into the latter two parameters of 
the following \texttt{compute} function, which checks for bonds and chooses the 
right interaction potential.
\begin{lstlisting}
%! codeblock: diatomicCompute
    __device__ real4 compute(real4 ri, real4 rj, int id_i, int id_j){
      const real3 rij = box.apply_pbc(make_real3(rj)-make_real3(ri));
      const real r2 = dot(rij, rij);
      if(r2 > 0 and r2 < rc*rc) {
        if(bondlist[id_i] == id_j) {
          const real r = sqrtf(r2);
          const real expar = exp(-a*(r - r0));
          const real oneminusexpar = real(1.0) - expar;
          return make_real4(-2.0*De*a*((expar - 1)*expar/r)*rij,
                            De*(oneminusexpar*oneminusexpar
                                - real(1.0)));
        } else {
          const real invr2 = (sigma*sigma)/r2;
          const real invr6 = invr2*invr2*invr2;
          return make_real4(epsilon*invr6*invr2
                            *(real(24.0) - real(48.0)*invr6)*rij,
                            4*epsilon*invr6*(invr6 - real(1.0)));
        }
      }
      else return real4();
    } //!
%! codeblockend !//
\end{lstlisting}
The \texttt{diatomic} structure ends with a \texttt{getForceEnergyTransverser}
method that feeds the necessary information into the \texttt{ForceEnergy}
constructor.
\begin{lstlisting}
%! codeblock: getForceTransverser
  ForceEnergy getForceEnergyTransverser(Box box,
                   std::shared_ptr<ParticleData> particles){
    auto force
      = particles->getForce(access::location::gpu,
                            access::mode::readwrite).raw();
    auto energy
      = particles->getEnergy(access::location::gpu,
                             access::mode::readwrite).raw();
    auto id
      = particles->getId(access::location::gpu,
                         access::mode::read);
    int * bondlist = thrust::raw_pointer_cast(bonds.data());
    return ForceEnergy(box, rc, force, energy, De, a, r0,
                       sigma, epsilon, bondlist, id.raw());
  }
}; //!
%! codeblockend !//
\end{lstlisting}

There you have it: a complete program simulating diatomic molecule formation and 
dissociation. It advances so slowly that you wouldn't use for any practical 
purpose, though, so what is the point I am trying to make here? In a single 
word, \textit{forethought}. Before you rush in to type your own lines of code, 
consider what was already implemented in UAMMD, what you need and what changes 
that implies and the benefits of coding for UAMMD. I do not mean to discourage 
you from playing around and learning from the code, if that is your idea of fun. 
Quite the opposite, UAMMD contains many neat simulation tricks worth learning. 
However, writing your own simulation from scratch may lead to even greater 
satisfaction and perhaps less work than trying to adapt your algorithm to the 
UAMMD infrastructure.

\bigbreak

These first two chapters have given you more than enough material to create your 
own simulations and use the output to create videos of spheres flying around and 
colliding in your own virtual world. But scientists aim at describing the real 
world, and that involves measuring interesting quantities in your system and 
relating them to physical objects, as we will see in the next chapter.

\begin{comment}
The complete diatomic potential data structure follows.
\begin{lstlisting}
%! codeblock: diatomicPairPotential
%! codeinsert: diatomicVariables

  real getCutOff() { return rc; }

%! codeinsert: diatomicConstructor

%! codeinsert: diatomicCreateBonds

%! codeinsert: diatomicForceEnergy

    __device__ void set(int id, real4 total){
      force[id] += make_real4(total.x, total.y, total.z, 0);
      energy[id] += real(0.5)*total.w;
    }
  };

%! codeinsert: getForceTransverser
%! codeblockend
\end{lstlisting}
\end{comment}

\begin{comment}
Based on the previous Morse.cu code, diatomic.cu implements bond formation and 
destruction with curve hopping.
\begin{lstlisting}
%! codefile: code/diatomic.cu
# include "uammd.cuh"
# include "utils/InitialConditions.cuh"
# include "Interactor/Potential/Potential.cuh"
# include "Interactor/NeighbourList/CellList.cuh"
# include "Interactor/PairForces.cuh"
# include "Integrator/VerletNVE.cuh"

using namespace uammd;
using std::make_shared;
using std::endl;

%! codeinsert: diatomicPairPotential

int main(int argc, char *argv[]){

  auto sys = make_shared<System>(argc, argv);

  %! codeinsert: diatomicParticleData

  %! codeinsert: latticeInitialConditions src: chapters/first_simulation.tex

  %! codeinsert: diatomicSetMass

  using Verlet = VerletNVE;
  Verlet::Parameters VerletParams;
  VerletParams.dt = 0.01;
  VerletParams.initVelocities = true;
  %! codeinsert: diatomicInitialEnergy

  %! codeinsert: Verlet src: chapters/first_simulation.tex

  %! codeinsert: addDiatomicPairPotential

  for(int step = 0; step < numberOfSteps; ++step) {
    %! codeinsert: createDiatomicBonds
    integrator->forwardTime();

    if(printEverynSteps > 0
       and step % printEverynSteps == 1) {
      %! codeinsert: printPositions src: chapters/first_simulation.tex
    }
  }

  sys->finish();

  return 0;
}
%! codeend
\end{lstlisting}
\end{comment}

\begin{comment}
List of programs written in this chapter:
%! codeblock: codelist
* `vibratingString.cu`: A chain of particles linked by harmonic springs and held
   tight at the ends behaving like a vibrating string (*section*: 2.1).
* `swingingRope.cu`: A chain of particles simulating a rope hanging from one of
   its ends, swinging back and forth in a gravitational field (*section*: 2.2).
* `cable.cu`: A chain of particles simulating a flexible cable bending under its
   own weight (*section*: 2.4).
* `curlyWire.cu`: A chain of particles behaving like a curly wire bending due to
   angular and torsional forces (*section*: 2.4).
* `MorseChain.cu`: A chain of particles connected with Morse bond potentials and
   attached to the origin in a uniform gravitational field (*section*: 2.5).
* `Morse.cu`: Particles in a periodic box interacting through a Morse potential
   (*section*: 2.6).
* `diatomic.cu`: A modification of `Morse.cu` in which bonds can only link
   particles together in pairs. All other interactions are treated with
   Lennard-Jones potentials (*section*: 2.7).
%! codeblockend
\end{comment}
